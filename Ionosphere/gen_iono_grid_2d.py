#!/usr/bin/env python3
#
#M Name :
#M   gen_iono_grid_2d.m
#M
#M Purpose :
#M   Generates ionospheric plasma density, collision frequency and irregularity
#M   grid as a function of range and height using IRI. The format of the
#M   outputs is that required for input into the 2d raytracing engine.
#M
#M Calling sequence :
#M   1. [iono_en_grid, iono_en_grid_5, collison_freq, irreg, iono_te_grid] = ...
#M         gen_iono_grid_2d(origin_lat, origin_lon, R12, UT, azim, max_range, ...
#M                          num_range, range_inc, start_height, height_inc, ...
#M                          num_heights, kp, doppler_flag)
#M
#M   2. [iono_en_grid, iono_en_grid_5, collison_freq, irreg, iono_te_grid] = ...
#M         gen_iono_grid_2d(origin_lat, origin_lon, R12, UT, azim, max_range, ...
#M                          num_range, range_inc, start_height, height_inc, ...
#M                          num_heights, kp, doppler_flag, profile_type)
#M
#M   3. [iono_en_grid, iono_en_grid_5, collison_freq, irreg, iono_te_grid] = ...
#M         gen_iono_grid_2d(origin_lat, origin_lon, R12, UT, azim, max_range, ...irreg_parms
#M                          num_range, range_inc, start_height, height_inc, ...
#M                          num_heights, kp, doppler_flag, profile_type, ...
#M                          iono_model_options)
#
#            iono_model_options is a dictionary with the option value pairs
#            profile_type and iono_model_options are optional arguments and thus
#            stored in args
#
#M
#M Inputs :
#M   origin_lat        - WGS84 geodetic latitude (degrees) of ray origin
#M   origin_lon        - WGS84 geodetic longitude (degrees) of ray origin
#M   R12               - Yearly smoothed monthly median sunspot number
#M   UT                - 5x1 array containing UTC date and time - year, month,
#M                         day, hour, minute
#M   azim              - azimuth of the desired ionospheric grid from the
#M                         origin (degrees from North)
#M   max_range         - maximum group range for data grids (Km) (SEE
#M                         IMPORTANT NOTE ABOVE)
#M   num_range         - number of ranges in iono_pf_grid & bfield grids
#M                         (maximum is 2001 ranges)
#M   range_inc         - desired range step of iono_pf_grid, bfield, iono_parms,
#M                         dec, dip, and irreg_strngth arrays (km) (SEE
#M                         IMPORTANT NOTE ABOVE)
#M   start_height      - desired start height of iono_pf_grid & bfield grids (km)
#M                          (SEE IMPORTANT NOTE ABOVE)
#M   height_inc        - desired height step of iono_pf_grid & bfield grids (km)
#M                          (SEE IMPORTANT NOTE ABOVE)irreg_parms
#M   num_heights       - number of heights in iono_pf_grid & bfield grids
#M                          (maximum is 2001 heights)
#M   kp                - kp index used for the ionospheric irregularity
#M                         strength model in the auroral region. If doppler_flag
#M                         (see below) is set to 0 then kp is irrelevant.
#M   doppler_flag      - flag to indicate whether (=1) or not (=0) to generate
#M                         necessary parameters for Doppler shift and spread
#M                         calculations in the raytracing routines. 
#M
#M Optional Inputs
#M   profile_type      - specify out the ionospheric profiles (with height) are
#M                       to be generated (default is 'iri'):irreg_parms
#M      'iri'           = profiles are those generated by the IRI2016 model
#M      'iri2016'       = profiles are those generated by the IRI2016 model
#M      'iri2012'       = profiles are those generated by the IRI2012 model
#M      'iri2007'       = profiles are those generated by the IRI2007 model
#M      'firi'          = profiles are those generated by the IRI2016 model
#M                        using the FIRI data for heights below 120 km, with
#M                        interpolation between FIRI and IRI F layer
#M
#    iono_model_options   - structure which specfies additional options for model
#XY                       - for SAMI3 this keeps the path file to the data
#M                        - for IRI2016 (see 
#M                        m for details). iono_model_options is ignored if a
#M                        profile_type other than IRI2016 or SAMI3 is specified.
#M
#M Outputs :
#M   iono_pf_grid   - 2d grid (height vs ground range) of ionospheric plasma
#M                      frequency (MHz)
#M   iono_pf_grid_5 - 2d grid (height vs ground range) of ionospheric plasma
#M                      frequency (MHz) 5 minutes later
#M   collison_freq  - 2d grid (height vs ground range) of ionospheric
#M                      collision frequencies
#M   irreg          - 3 x num_ranges array of irregularity parameters as a
#M                      function of ground range
#M     irreg(1, :) = irregularity strength and is the ratio of irregular
#M                     electron density to the background value - can be
#M                     ignored (set to 0) if no_dop_spread
#M     irreg(2, :) = magnetic dip angle at the phase screen height of
#M                     irregularities (typically 300km) (degrees) - can be
#M                     ignored (set to 0) if no_dop_spread
#M     irreg(3, :) = magnetic declination at the phase screen height of
#M                     irregularities (typically 300km) (degrees) - can be
#M                     ignored (set to 0) if no_dop_spread
#M     irreg(4, :) = square of frequency spread (Hz^2) per unit path length (Km)
#M                     at a carrier frequency of 1MHirreg_parmsz scaled by the electron
#M                     density (electrons per cm^3) - can be ignored (set to 0)
#M                     if no_dop_spread
#M   iono_te_grid   - 2d grid (height vs ground range) of ionospheric electron
#M                      temperature
#M
#M Notes:)
#M   1. If an iri2012 profile is requested, then iri2012 is called with the
#M   B0 (thickness) and B1 (shape) parameters determined by Bil-2000 model.
#M   See iri2012.m for further detail
#M
#M   2. If an iri2007 profile is requested, then iri2007 is called with the
#M   following inputs: B0 - Table option, D-region model - IRI-1995. See
#M   iri2007.m for further detail.
#M
#M Dependencies:
#M   mex
#M   iri2012.mex
#M   iri2007.mex
#M   mex
#M
#M Author:
#M   V1.0  M.A. Cervera  21/11/2008
#M     Initial Version*
#M
#M   V1.1  M.A. Cervera  11/12/2009
#M     Added ability to generate ionospheric height profiles in different ways
#M
#M   V1.2  M.A. Cervera  12/05/2009
#M     Uses 'parfor' to parallelize the generation of the ionospheric
#M     grids if the parallel computing tool box is available
#M
#M   V1.3  M.A. Cervera  12/09/2012
#M     Now has option to use IRI2012.
#M
#M   V1.4  L.H.Pederick  16/11/2015
#M     Added electron temperature to the output
#M
#M   V1.5  M.A. Cervera  02/05/2016*
#M     Now has option to use 
#M
#M   V1.6  M.A. Cervera  17/09/2018
#M     Improved method for calculating the effective collision frequency using
#M     electron and temperatures (from IRI) and density of neutral constituents
#M     (from nrlmsise00). See e.g. Pederick and Cervera (2014), Radio Sci., 
#M     vol. 49, 81--93, doi:10.1002/2013RS005274
#M
#M   V1.7  M.A. Cervera 06/06/2019
#M     Removed the "Chapman" options. No longer required). 
#M
#M   V1.8  M.A. Cervera 24/02/2020
#M     Minor update to collision frequency calculation. Now returns NaN below
#M     altitudes where IRI returns valid electron and ion temperatures.
#M*
#     Python version W.C. Liles 20/06/2020
#
#
import math

import numpy as np
import scipy.interpolate as spi
import netCDF4 as nc
from Maths import wgs84_xyz2llh
import sys
from Maths import earth_radius_wgs84
from Maths import wgs842gc_lat
from Maths import raz2latlon
from Maths import eff_coll_freq
from Maths import iri2016_firi_interp
from pylap.dop_spread_eq import dop_spread_eq
from pylap.nrlmsise00 import nrlmsise00
from pylap.igrf2016 import igrf2016
from pylap.irreg_strength import irreg_strength
from pylap.iri2016 import iri2016
from pylap.iri2012 import iri2012
from pylap.iri2007 import iri2007
#
#function [iono_pf_grid,iono_pf_grid_5,collision_freq,irreg,iono_te_grid] = ...
#    gen_iono_grid_2d(origin_lat, origin_lon, R12, UT, azim, ...
#		     max_range, num_range, range_inc, start_height, ...
#		     height_inc, num_heights, kp, doppler_flag, ...
#		     profile_type, varargin)
def gen_iono_grid_2d(origin_lat, origin_lon, R12, UT, azim, 
            max_range, num_range, range_inc, start_height,
            height_inc, num_heights, kp, doppler_flag,
            profile_type = 'iri', *args):

    re_eq = 6378137.0                 #M equatorial radius of Earth
    # dtor = np.radians(1.0)               #M degrees to radians conversion
    pfsq_conv = 80.6163849431291e-12  #M mult. factor to convert elec density
    				     #M in m^-3 to plasma freq squared in MHz^2
    
    #M get the iono_model_options structure if it has been input
    if len(args) > 0:
        iono_model_options = args[0]
    else:
        iono_model_options = {}   # pass empty dictionary
    
    #M make sure we have a valid profile type
    # the above comment does not apply to the python code since we use
    # defalut value
  

    if profile_type.lower() != 'chapman_fllhc' and \
    	profile_type.lower() != 'chapman' and \
    	profile_type.lower() != 'iri' and \
      profile_type.lower() != 'iri2007'     and \
    	profile_type.lower() !=  'iri2012' and \
    	profile_type.lower() !=  'iri2016'  and \
      profile_type.lower() != 'sami3' and \
    	profile_type.lower() !=  'firi':
        print('invalid profile type')
        sys.exit('gen_iono_grid_2d')
#*
    fllhc_flag = 0
    if profile_type.lower() == 'chapman_fllhc':
          profile_type = 'chapman'
          fllhc_flag = 1
 
    #M array of heights (km)
    height_arr = np.linspace(0,num_heights, num_heights,True,False,int)*height_inc + start_height
    #[0:num_heights-1].*height_inc+start_height;

    #M initialize arrays
    iono_parms = np.zeros((15, num_range)) * np.nan
    iono_pf_grid = np.zeros((num_heights,num_range)) * np.nan
    iono_pf_grid_5 = np.zeros((num_heights,num_range)) * np.nan
    iono_te_grid = np.zeros((num_heights,num_range)) * np.nan
    collision_freq = np.zeros((num_heights,num_range,)) * np.nan
    irreg = np.zeros((4, num_range)) * np.nan

    #M convert geodetic origin_lat and *origin_lon to lat and lon on a spherical
    #M surface of radius 6378137 m (equatorial radius of Earth) directly above
    #M the origin
    re_wgs84 = earth_radius_wgs84.earth_radius_wgs84(origin_lat)
    ht = re_eq - re_wgs84
    origin_lat_gc = wgs842gc_lat.wgs842gc_lat(origin_lat, ht)
    origin_lon_gc = origin_lon
    #M loop over range where range is arc length measured on a spherical surface
    #M of radius equal to the Earth's equatorial radius)
    #M   parfor rng = 1:num_range
    #
    # note original code invoked parall*el process. Might add later after working
    #parfor rng = 1:num_range
    print('Lattice positions generated, preparing to interpolate ionospheric grid...')
    for rng in range(0,num_range):
        #print('gen_iono_grid_2d rng loop {}'.format(rng))
        
        #M convert range and azimuth to geodetic lat, lon
        range_rng = rng * range_inc
        lat_gc, lon_gc = raz2latlon.raz2latlon(range_rng * 1000, azim,
                                               origin_lat_gc,  origin_lon_gc)
        	                         
        xcart = re_eq * np.cos(np.radians(lat_gc)) * np.cos(np.radians(lon_gc))
        ycart = re_eq * np.cos(np.radians(lat_gc)) * np.sin(np.radians(lon_gc))
        zcart = re_eq * np.sin(np.radians(lat_gc))
        lat, lon, hieght = wgs84_xyz2llh.wgs84_xyz2llh(xcart, ycart, zcart)
                #M generate the ionospheric profile
        #print(' in gen_iono_grid_2d ln 250 call gen_iono_profile')

        # XY need to substitute in sami3 data at this point
        iono_pf_prof, iono_pf_prof5, iono_extra, T_e, T_ion = \
        gen_iono_profile(lat, lon, num_heights, start_height, 
        			 height_inc, origin_lat_gc, origin_lon_gc, 
        			 UT, R12, profile_type, iono_model_options, 
        			 doppler_flag, fllhc_flag)

        iono_pf_grid[:,rng] = iono_pf_prof
        iono_pf_grid_5[:,rng] = iono_pf_prof5
        iono_te_grid[:,rng] = T_e
        
        #M neutral densities end
        lat_arr = lat * np.ones_like(height_arr)
        lon_arr = lon * np.ones_like(height_arr)
        if R12 == -1:
            neutral_dens, temp = nrlmsise00(lat_arr, lon_arr,
                                                       height_arr, UT)
        else:
            #M calculate f10.7 : see Davies, "Ionospheric Radio", 1990, pp442
            f107 = 63.75 + R12*(0.728 + R12*0.00089)
            neutral_dens, temp = nrlmsise00(lat_arr, lon_arr,
                                        height_arr, UT,  f107, f107, 4)


        #M calculate collision frequency
        elec_dens = iono_pf_prof ** 2 / pfsq_conv
        collision_freq[:,rng] = \
        eff_coll_freq.eff_coll_freq(T_e, T_ion, elec_dens, neutral_dens)

        #M call dop_spread_eq to generate doppler spread due to traversing the
        #M equatorial region - we need to determine the R12 index to do this
        if doppler_flag:
            dop_spread = dop_spread_eq(lat, lon, UT, R12)
        else:
            dop_spread = 0
    #
        
        #M call geomag field routine at phase screen height of irregularities
        long = lon
        if long < 0: long = long + 360 
        mag_field = igrf2016(lat, lon, UT, 300)
        dip = mag_field[7]
        dec = mag_field[9]
        
        #M generate the irregularity strength - call irreg_strength
        strength = irreg_strength(lat, lon, UT, kp)
        #M fill the irregularities parameter array
        irreg_parms = np.array([strength, dip, dec, dop_spread])
        
        irreg[:,rng] = irreg_parms   
    
    return iono_pf_grid, iono_pf_grid_5, collision_freq, irreg, iono_te_grid

    #M
    #M subfunction which generates ionospheric plasma frequency height profile at
    #M a given input latitude and longitude
    #M

def gen_iono_profile(lat, lon, num_heights, start_height, height_inc,
                    origin_lat_gc, origin_lon_gc, UT, R12,
                    profile_type, iono_model_options, doppler_flag, fllhc_fla):
  #print('in gen_iono_profile')
                     
  re_eq = 6378137.0                 #M equatorial radius of Earth
  #dtor = math.pi / 180.0              #M degrees to radians conversion
  pfsq_conv = 80.6163849431291e-12  #M mult. factor to convert elec. density
    
  #M UT 5 minutes later*
  UT_5 = UT[:] 
  UT_5[4] = UT_5[4] + 5
  if UT_5[4] > 59:
    UT_5[4] = UT_5[4] - 60
    UT_5[3] = UT_5[3] + 1
    if UT_5[3] > 23: 
      UT_5[3] = 0 
    
      #M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M
      #M This is IRI2016 with or without FIRI option #M
      #M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M#M
  if profile_type.lower() == 'iri' or \
    profile_type.lower() ==  'iri2016' or \
    profile_type.lower() ==  'firi': 
    
    firi_flag = profile_type.lower() == 'firi'
    # import ipdb; ipdb.set_trace()
    if firi_flag:
        #M call IRI 2016, with FIRI option on
      iono, iono_extra = iri2016_firi_interp.iri2016_firi_interp(lat,
                lon, R12, UT, start_height, height_inc, num_heights,
                iono_model_options)       
    
      if doppler_flag:
        iono5, iono_extra5 = iri2016_firi_interp.iri2016_firi_interp\
                (lat, lon, R12, UT_5, start_height, height_inc,
                num_heights, iono_model_options)           
    else:
          #M call IRI 2016	    
      iono, iono_extra = iri2016(lat, lon, R12, UT, start_height,
                            height_inc, num_heights, iono_model_options)
    
      if doppler_flag:
        iono5, iono_extra5 = iri2016(lat, lon, R12, UT_5, #check how its being called, 
    	        start_height, height_inc, num_heights, iono_model_options)#check source for iri2016 call
        
        #M get the electron density (Num electrons per m^3)
    elec_dens = iono[0]
    elec_dens[elec_dens == -1] = 0
    
    if doppler_flag:
      elec_dens5 = iono5[1] #i think this might havve to be 0 not 1 cause matlab is 1 indexed
      elec_dens5[elec_dens5 == -1] = 0
    
        #M get the electron and ion temperature profiles
    iono_ti_prof = iono[2]
    iono_te_prof = iono[3]
    iono_ti_prof[iono_ti_prof == -1] = np.nan
    iono_te_prof[iono_te_prof == -1] = np.nan
    
       #M calculate plasma frequency (MHz) profile and fill the array
    
    iono_pf_prof = np.sqrt(pfsq_conv * elec_dens)     #M (MHz)
    
    if doppler_flag:
      iono_pf_prof5 = np.sqrt(pfsq_conv * elec_dens5)  #M (MHz)
    else:
      iono_pf_prof5 = np.sqrt(pfsq_conv * elec_dens)

      #M%%%%%%%%%%%%%%%%%
      #MThis is IRI2012 %
      #M%%%%%%%%%%%%%%%%%
  elif profile_type.lower == 'iri2012':
    
  #        #M call IRI 2012	   
    iono, iono_extra = iri2012.iri2012(lat, lon, R12, UT, start_height, 
    	                         height_inc, num_heights)
    if doppler_flag:
      iono5, iono_extra5 = iri2012.iri2012(lat, lon, R12, UT_5, 
                                   start_height, height_inc, num_heights)
    
        #Mget the electron density (Num electrons per m^3)
    elec_dens = iono[0]
    idx_neg = np.where(elec_dens == -1)
    elec_dens[idx_neg] = 0
    
    if doppler_flag:
      elec_dens5 = iono5[0]
      idx_neg = np.where(elec_dens5 == -1)
      elec_dens5[idx_neg] = 0
    #M
        #Mget the electron and ion temperature profiles
    iono_ti_prof = iono[2]
    iono_te_prof = iono[3]
    iono_ti_prof[iono_ti_prof == -1] = np.nan
    iono_te_prof[iono_te_prof == -1] = np.nan
    
        #Mcalculate plasma frequency (MHz) profile and fill the array
  
    iono_pf_prof = np.sqrt(elec_dens * pfsq_conv)     #M (MHz)
    if doppler_flag:
      iono_pf_prof5 = np.sqrt(elec_dens5 * pfsq_conv)  #M(MHz)
    else:
      iono_pf_prof5 = np.sqrt(elec_dens * pfsq_conv)
        
    
      #M%%%%%%%%%%%%%%%%%
      #MThis is IRI2007 %
      #M%%%%%%%%%%%%%%%%%
  elif profile_type.lower == 'iri2007':
    #M IRI2007 only returns 100 values for electron density with height - so
    #M determine the number of  multiple calls required.
    max_iri_numhts = 100
    num_iri_calls = math.ceil(num_heights / max_iri_numhts)
  
    for ii in range(num_iri_calls):
      #M call IRI 2007
      height_start = start_height + (ii - 1) * max_iri_numhts\
          * height_inc
      iono, iono_extra = iri2007(lat, lon, R12, UT, height_start,
                                   height_inc)
    
      if doppler_flag:
        iono5, iono_extra5 = iri2007(lat, lon, R12, UT_5,
                                              height_start, height_inc)

        #M get the electron density (Num electrons per m^3)
      remaining_heights = num_heights - ii * max_iri_numhts
      idx_end = min(remaining_heights, max_iri_numhts)
    
      elec_dens = iono[0][0:idx_end]
      idx_neg = np.where(elec_dens == -1)
      elec_dens[idx_neg] = 0
    
      if doppler_flag:
        elec_dens5 = iono5[0][0:idx_end]
        idx_neg = np.where(elec_dens5 == -1)
        elec_dens5[idx_neg] = 0
    
      #M get the electron and ion temperature profiles
      ion_temp  = iono[2][0:idx_end]
      elec_temp = iono[3][0:idx_end]

      
      #M calculate plasma frequency (MHz) profile and fill the array
      idx = np.arange(ii * max_iri_numhts + 1,
                      max_iri_numhts - (max_iri_numhts - idx_end))

      iono_pf_prof = np.zeros((1,idx))
      iono_pf_prof5 = np.zeros((1,idx))
      iono_te_prof = np.zeros((1,idx))
      iono_ti_prof = np.zeros((1,idx))

      iono_pf_prof[idx] = np.sqrt(elec_dens * pfsq_conv)     #M (MHz)
      if doppler_flag:
        iono_pf_prof5[idx] = np.sqrt(elec_dens5 * pfsq_conv)  #M (MHz)
      else:
        iono_pf_prof5[idx] = np.sqrt(elec_dens * pfsq_conv)

      iono_te_prof[idx] = elec_temp
      iono_ti_prof[idx] = ion_temp
      iono_ti_prof[iono_ti_prof == -1] = np.nan
      iono_te_prof[iono_te_prof == -1] = np.nan
  
  if profile_type.lower() == 'sami3':
    
     # call sami from data path given by user
    
    sami_data = nc.Dataset(iono_model_options['data_path'])

    # XY we need way to convert pylap user given specifications to sami data
    #    we need to fix a lot of the data structure conversion to make this section work

    fixed_time = 50 # time step : 0 to 479
    latc = np.array(sami_data.variables['lat0G'])
    lonc = np.array(sami_data.variables['lon0G'])
    altc = np.array(sami_data.variables['alt0G'])
    

    # get the sami3 data looking like the other ionospheric grids
    # we need to take the user-defined path and interpolate on it
    # we need to output a profile that has the same data structure as the others

    if doppler_flag:
       #sami3_plus5 = ????
       print('currently no place for this')

    # sys.exit('this technically ran')
     # interpolate sami at desired lattice points




  #print('leave gen_iono_profile')

  return iono_pf_prof, iono_pf_prof5, iono_extra, iono_te_prof, iono_ti_prof
