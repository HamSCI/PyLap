#!/usr/bin/env python3
# % Name :
# %   gen_iono_grid_3d.m
# %
# % Purpose :
# %   Generates ionospheric plasma density, collision frequency and irregularity
# %   grid as a function of range and height using IRI. Gridded geomagnetic
# %   field data (generated using IGRF) is also returned. The format of the
# %   outputs is that required for input into the 3d raytracing engine.
# %
# % Calling sequence :
# %   1. [iono_pf_grid, iono_pf_grid_5, collision_freq, Bx, By, Bz] = ...
# %         gen_iono_grid_3d(UT, R12, iono_grid_parms, geomag_grid_parms, ...
# %                          doppler_flag)
# %
# %   2. [iono_pf_grid, iono_pf_grid_5, collision_freq, Bx, By, Bz] = ...
# %         gen_iono_grid_3d(UT, R12, iono_grid_parms, geomag_grid_parms, ...
# %                          doppler_flag, profile_type)
# %
# %   3. [iono_pf_grid, iono_pf_grid_5, collision_freq, Bx, By, Bz] = ...
# %         gen_iono_grid_3d(UT, R12, iono_grid_parms, geomag_grid_parms, ...
# %                          doppler_flag, profile_type)
# %
# % Inputs :
# %   UT                - 5x1 array containing UTC date and time - year, month,
# %                         day, hour, minute
# %   R12               - scalar R12 index
# %      R12 = 1 - 200 :  IRI is called with R12 (Zurich V1.0) input as the
# %                       user specified yearly smoothed monthly median sunspot
# %                       number.  
# %      R12 = -1      :  IRI is called with ionospheric conditions (R12,
# %                       IG12, and F10.7) read from file (ig_rz.dat) based on
# %                       input epoch (UT) and may be historical or projected
# %                       conditions (dependent on the epoch). 
# %
# %   iono_grid_parms   - 9x1 vector containing the parameters which define the
# %                       ionospheric grid :
# %           (1) geodetic latitude (degrees) start
# %           (2) latitude step (degrees)
# %           (3) number of latitudes
# %           (4) geodetic longitude (degrees) start
# %           (5) lonitude step (degrees)
# %           (6) number of longitudes
# %           (7) geodetic height (km) start
# %           (8) height step (km)
# %           (9) number of heights
# %
# %   geomag_grid_parms - 9x1 vector containing the parameters which define the
# %                       geomagnetic grid :
# %           (1) geodetic latitude (degrees) start
# %           (2) latitude step (degrees)
# %           (3) number of latitudes
# %           (4) geodetic lonitude (degrees) start
# %           (5) longitude step (degrees)
# %           (6) number of longitudes
# %           (7) geodetic height (km) start
# %           (8) height step (km)
# %           (9) number of heights
# %
# %   doppler_flag      - flag to indicate whether (=1) or not (=0) to generate
# %                       necessary parameters for Doppler shift and spread
# %                       calculations in the raytracing routines. NB turning
# %                       this on will increase the time required to generate
# %                       the ionosphere.
# %
# % Optional Inputs
# %   profile_type      - specify how the ionospheric profiles (with height) are
# %                       to be generated (default is 'iri') (see also Notes) :
# %      'iri'           = profiles are those generated by the IRI2016 model
# %      'iri2016'       = profiles are those generated by the IRI2016 model
# %      'iri2012'       = profiles are those generated by the IRI2012 model
# %      'iri2007'       = profiles are those generated by the IRI2007 model
# %      'firi'          = profiles are those generated by the IRI2016 model
# %                        using the FIRI data for heights below 120 km, with
# %                        interpolation between FIRI and IRI F layer
# %
# %   iri_options        - structure which specfies options for IRI2016 (see 
# %                        m for details). iri_options is ignored if a
# %                        profile_type other than IRI2016 is specified.
# %
# % Outputs :
# %   iono_pf_grid   - 3d grid (height vs lat. vs lon.) of ionospheric plasma
# %                      frequency (MHz)
# %   iono_pf_grid_5 - 3d grid (height vs lat. vs lon.) of ionospheric plasma
# %                      frequency (MHz) 5 minutes later
# %   collison_freq  - 3d grid (height vs lat. vs lon.) of ionospheric
# %                      collision frequencies
# %   Bx             - 3d grid of x component of geomagnetic field
# %   By             - 3d grid of y component of geomagnetic field
# %   Bz             - 3d grid of z component of geomagnetic field
# %
# % Notes:
# %   1. If an iri2012 profile is requested, then iri2012 is called with the
# %   following inputs: B0B1_model = 2 (B0 thickness and B1 shape parameters
# %   determined by Bil-2000 model), D_model = 1 (IRI-1990 model for D layer).
# %   See iri2012.m for further detail
# %
# %   2. If an iri2007 profile is requested, then iri2007 is called with the
# %   following inputs: B0 - Table option, D-region model - IRI-1995. See
# %   iri2007.m for further detail.

# %
# % Dependencies:
# %   mex
# %   iri2012.mex
# %   iri2007.mex
# %   igrf2016.mex
# %   igrf2011.mex
# %   igrf2007.mex
# %   solar_za.m
# %
# % Modification History:
# %   V1.0  M.A. Cervera  25/06/2010
# %     Initial Version
# %
# %   V1.1  M.A. Cervera  12/09/2012
# %     Updated to use IRI2012 and IGRF2011
# %
# %   V1.2  M.A. Cervera  03/05/2016
# %     Updated to use IRI2016 and IGRF2016
# %
# %   V1.3  M.A. Cervera  17/09/2018
# %     Improved method for calculating the effective collision frequency using
# %     electron and temperatures (from IRI) and density of neutral constituents
# %     (from nrlmsise00). See e.g. Pederick and Cervera (2014), Radio Sci., 
# %     vol. 49, 81--93, doi:10.1002/2013RS005274
# %
# %   V1.4  M.A. Cervera 06/06/2019
# %     Removed the "Chapman" options. No longer required. Tidied up help.
# %
# %   V1.5  M.A. Cervera 24/02/2020
# %     Minor update to collision frequency calculation. Now returns NaN below
# %     altitudes where IRI returns valid electron and ion temperatures.
# %

# function [iono_pf_grid, iono_pf_grid_5, collision_freq, Bx, By, Bz] = ...
#          gen_iono_grid_3d(UT, R12, iono_grid_parms, geomag_grid_parms, ...
#                           doppler_flag, profile_type, varargin)
import math
import numpy as np
#
import sys
from Maths import ENU2xyz
from Maths import wgs84_xyz2llh
from Maths import earth_radius_wgs84
from Maths import wgs842gc_lat
from Maths import raz2latlon
from Maths import eff_coll_freq
from Maths import iri2016_firi_interp
from pylap.dop_spread_eq import dop_spread_eq
from pylap.nrlmsise00 import nrlmsise00
from pylap.igrf2016 import igrf2016
from pylap.irreg_strength import irreg_strength
from pylap.iri2016 import iri2016
from pylap.iri2012 import iri2012
from pylap.iri2007 import iri2007

def gen_iono_grid_3d(UT, R12, iono_grid_parms,
                     geomag_grid_parms, doppler_flag, 
                     profile_type='iri', *args):
    pfsq_conv = 80.6163849431291e-12;  #% mult. factor to convert electron density
#                                      % in m^-3 to plasma freq. squared in MHz^2

#   % get the iri_options structure if it has been input
    if len(args) > 0:
        iri_options = args[0]
    else:
        iri_options = {}

    if profile_type.lower() != 'chapman_fllhc' and \
    	profile_type.lower() != 'chapman' and \
    	profile_type.lower() != 'iri' and \
      profile_type.lower() != 'iri2007'     and \
    	profile_type.lower() !=  'iri2012' and \
    	profile_type.lower() !=  'iri2016'  and \
    	profile_type.lower() !=  'firi':
        print('invalid profile type')
        sys.exit('gen_iono_grid_2d')
#*
    fllhc_flag = 0
    if profile_type.lower() == 'chapman_fllhc':
          profile_type = 'chapman'
          fllhc_flag = 1
          
#   % ionospheric and geomagnetic grid definition
    lat_min = iono_grid_parms[0]
    lat_inc = iono_grid_parms[1]
    num_lat = iono_grid_parms[2]
    lon_min = iono_grid_parms[3]
    lon_inc = iono_grid_parms[4]
    num_lon = iono_grid_parms[5]
    ht_min = iono_grid_parms[6]
    ht_inc = iono_grid_parms[7]
    num_ht = iono_grid_parms[8]

    B_lat_min = geomag_grid_parms[0]
    B_lat_inc = geomag_grid_parms[1]
    B_num_lat = geomag_grid_parms[2]
    B_lon_min = geomag_grid_parms[3]
    B_lon_inc = geomag_grid_parms[4]
    B_num_lon = geomag_grid_parms[5]
    B_ht_min = geomag_grid_parms[6]
    B_ht_inc = geomag_grid_parms[7]
    B_num_ht = geomag_grid_parms[8]
    
#   % initialize arrays
    iono_pf_grid = np.zeros((int(num_lat), int(num_lon), int(num_ht))) * np.nan
    iono_pf_grid = np.zeros((int(num_lat), int(num_lon), int(num_ht))) * np.nan
    iono_pf_grid_5 = np.zeros((int(num_lat), int(num_lon), int(num_ht))) * np.nan
    collision_freq = np.zeros((int(num_lat), int(num_lon), int(num_ht))) * np.nan
    Bx = np.zeros((B_num_lat, B_num_lon, B_num_ht))
    By = np.zeros((B_num_lat, B_num_lon, B_num_ht))
    Bz = np.zeros((B_num_lat, B_num_lon, B_num_ht))

#   % generate ionospheric grids
#   %
    lat_max = lat_min + (num_lat - 1) * lat_inc
    lon_max = lon_min + (num_lon - 1) * lon_inc
    ht_max = ht_min + (num_ht - 1) * ht_inc
    height_arr = np.arange(ht_min, ht_max, ht_inc, dtype = float)
    lat_idx = 0
    for lat_idx in range(int(num_lat-1),-1,-1):
        lat = lat_min + (lat_idx - 1) * lat_inc
        # % generate ionosphere gridded in longitude and height
        [iono_pf_subgrid, iono_pf_subgrid_5, collision_freq_subgrid] = \
        gen_iono_subgrid(lat, lon_min, lon_inc, lon_max, ht_min, ht_inc, 
                        ht_max, R12, UT, profile_type, doppler_flag, 
                        iri_options, fllhc_flag)
        
        # % populate the ionospheric (lat,lon,height) grids
        iono_pf_grid[lat_idx, :, :] = iono_pf_subgrid
        iono_pf_grid_5[lat_idx, :, :] = iono_pf_subgrid_5
        collision_freq[lat_idx, :, :] = collision_freq_subgrid
        
#   %
#   % generate magnetic field grids
#   %
    B_lat_max = B_lat_min + (B_num_lat - 1) * B_lat_inc
    B_lon_max = B_lon_min + (B_num_lon - 1) * B_lon_inc
    B_ht_max = B_ht_min + (B_num_ht - 1) * B_ht_inc
    for B_lat_idx in range(int(B_num_lat),-1,-1): 
        lat = B_lat_min + (B_lat_idx - 1) * B_lat_inc

    #% generate magnetic field gridded in longitude and height
        [Bx_subgrid, By_subgrid, Bz_subgrid] = \
	    gen_Bfield_subgrid(lat, B_lon_min, B_lon_inc, B_lon_max, 
	                   B_ht_min, B_ht_inc, B_ht_max, UT)

    #% populate the magnetic field (lat,lon,height) grids
        Bx[B_lat_idx-1, :, :] = Bx_subgrid
        By[B_lat_idx-1, :, :] = By_subgrid
        Bz[B_lat_idx-1, :, :] = Bz_subgrid

    return iono_pf_grid, iono_pf_grid_5, collision_freq, Bx, By, Bz

# %
# % subfunction which generates geomagnetic field gridded over longitude and
# % height for a given input latitude
# %
def gen_Bfield_subgrid(lat, B_lon_min, B_lon_inc, B_lon_max, 
	                   B_ht_min, B_ht_inc, B_ht_max, UT):
    lon_idx = -1

    sizeX = int(((B_lon_max-B_lon_min+B_lon_inc) /B_lon_inc))
    sizeY = int(((B_ht_max-B_ht_min+B_ht_inc) /B_ht_inc))
    Bx_subgrid = np.zeros((sizeX, sizeY))
    By_subgrid = np.zeros((sizeX, sizeY))
    Bz_subgrid = np.zeros((sizeX, sizeY))
    
    for lon in range(int(B_lon_min), int(B_lon_max+B_lon_inc),int(B_lon_inc)):
        lon_idx = lon_idx + 1
        ht_idx = -1
        for height in range(B_ht_min,B_ht_max+B_ht_inc,B_ht_inc):
            ht_idx = ht_idx + 1

            mag_field = igrf2016(lat, lon, UT, height)
            field_N = mag_field[0]
            field_E = mag_field[1]
            field_U = -mag_field[2]
            [field_x, field_y, field_z] = ENU2xyz.ENU2xyz(field_E, field_N, field_U, 
	                                    lat, lon)

            Bx_subgrid[lon_idx][ht_idx] = field_x
            By_subgrid[lon_idx][ht_idx] = field_y
            Bz_subgrid[lon_idx][ht_idx] = field_z

    return Bx_subgrid, By_subgrid, Bz_subgrid

# %
# % subfunction which generates ionospheric data gridded over longitude and
# % height for a given input latitude
def gen_iono_subgrid(lat, lon_min, lon_inc, lon_max, ht_min, ht_inc, 
                        ht_max, R12, UT, profile_type, doppler_flag, 
                        iri_options, fllhc_flag):
    pfsq_conv = 80.6163849431291e-12;    #% multiplicative factor to convert 
#                                        % electron dens (m^3) to 
#                                        % plasma freq. squared (MHz^2)

    height_arr = np.arange(ht_min, ht_max+ht_inc, ht_inc, dtype = float)
    lat_arr = lat * np.ones_like(height_arr) 

#M UT 5 minutes later*
    UT_5 = UT[:] 
    UT_5[4] = UT_5[4] + 5
    if UT_5[4] > 59:
        UT_5[4] = UT_5[4] - 60
        UT_5[3] = UT_5[3] + 1
    if UT_5[3] > 23: 
        UT_5[3] = 0 

    lon_idx = -1
    iono_pf_subgrid = np.zeros((int(lon_max-lon_min+1), 201))
    collision_freq_subgrid= np.zeros((int(lon_max-lon_min+1), 201))
    for lon in range(int(lon_min),int(lon_max+lon_inc),int(lon_inc)):
        lon_idx = lon_idx + 1
        lon_arr = np.ones_like(height_arr) *lon
        
#     %%%%%%%%%%%%%%%%%%%
#     % This is IRI2016 %#     %%%%%%%%%%%%%%%%%%%
        if profile_type.lower() == 'iri' or \
            profile_type.lower() ==  'iri2016': 

            num_heights = round((ht_max - ht_min)/ht_inc) + 1
#       % call IRI2016
            [iono, iono_extra] = iri2016(lat, lon, R12, UT, ht_min, ht_inc, 
 	                           num_heights, iri_options)

            if doppler_flag:
                [iono5, iono_extra5] = iri2016(lat, lon, R12, UT_5, ht_min, ht_inc, 
 	                               num_heights, iri_options)
#       % get the electron density (Num electrons per m^3)
            elec_dens = iono[0][:]
            elec_dens[elec_dens == -1] = 0

            if doppler_flag:
                elec_dens5 = iono5[0] 
                elec_dens5[elec_dens5 == -1] = 0
            
#       % calculate plasma frequency (MHz) profile and fill the array
            
            iono_pf_subgrid[lon_idx] = np.sqrt(elec_dens * pfsq_conv); 
            if doppler_flag:
                iono_pf_subgrid_5 = np.sqrt(elec_dens5 * pfsq_conv)  
            else:
                iono_pf_subgrid_5 = np.sqrt(elec_dens * pfsq_conv)

#       % electron and ion temperatures
            T_e = iono[3]
            T_e[T_e == -1] = np.nan

            T_ion = iono[2]
            T_ion[T_ion == -1] = np.nan
#       % neutral densities
            if (R12 == -1):
                [neutral_dens, temp] = nrlmsise00(lat_arr, lon_arr, height_arr, UT)
            else:
# 	% calculate f10.7 : see Davies, "Ionospheric Radio", 1990, pp442
                f107 = 63.75 + R12*(0.728 + R12*0.00089)
                [neutral_dens, temp] = \
                nrlmsise00(lat_arr, lon_arr, height_arr, UT, f107, f107, 4)

#       % calculate collision frequency
            collision_freq_subgrid[lon_idx,:] = \
            eff_coll_freq.eff_coll_freq(T_e, T_ion, elec_dens, neutral_dens)
#     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#     % This is IRI2016 with FIRI option on %
#     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        elif profile_type.lower == 'firi':

            num_heights = round((ht_max - ht_min)/ht_inc) + 1

#       % call IRI 2016, with FIRI option on
            [iono, iono_extra] = iri2016_firi_interp.iri2016_firi_interp(lat, lon, R12, UT, ht_min, ht_inc,
	        num_heights, iri_options)

            if doppler_flag:
                [iono5, iono_extra5] = iri2016_firi_interp.iri2016_firi_interp(lat, lon, R12, UT_5, ht_min, ht_inc,
	            num_heights, iri_options)
#           end
#           % get the electron density (Num electrons per m^3)
            elec_dens = iono[0][:]
            elec_dens[elec_dens == -1] = 0

            if doppler_flag:
                elec_dens5 = iono5[0,:]
                elec_dens5[elec_dens == -1] = 0

#       % calculate plasma frequency (MHz) profile and fill the array
            iono_pf_subgrid[lon_idx] = np.sqrt(elec_dens * pfsq_conv); 
            if doppler_flag:
                iono_pf_subgrid_5 = np.sqrt(elec_dens5 * pfsq_conv)  
            else:
                iono_pf_subgrid_5 = np.sqrt(elec_dens * pfsq_conv)

#       % electron and ion temperatures

            T_e = iono[3]
            T_e[T_e == -1] = np.nan

            T_ion = iono[2]
            T_ion[T_ion == -1] = np.nan
            
            # % neutral densities
            if (R12 == -1):
                [neutral_dens, temp] = nrlmsise00(lat_arr, lon_arr, height_arr, UT)
            else:
    # 	% calculate f10.7 : see Davies, "Ionospheric Radio", 1990, pp442
                f107 = 63.75 + R12*(0.728 + R12*0.00089)
                [neutral_dens, temp] = \
                nrlmsise00(lat_arr, lon_arr, height_arr, UT, f107, f107, 4)

    #       % calculate collision frequency
                collision_freq_subgrid[lon_idx,:] = \
                eff_coll_freq.eff_coll_freq(T_e, T_ion, elec_dens, neutral_dens)

#     %%%%%%%%%%%%%%%%%%%
#     % This is IRI2012 %
#     %%%%%%%%%%%%%%%%%%%
#       elseif (strcmp(lower(profile_type), 'iri2012') )
        elif profile_type.lower() == 'iri2012' : 

            num_heights = round((ht_max - ht_min)/ht_inc) + 1
#       % call IRI2016
            [iono, iono_extra] = iri2012(lat, lon, R12, UT, ht_min, ht_inc, 
 	                           num_heights, iri_options)

            if doppler_flag:
                [iono5, iono_extra5] = iri2012(lat, lon, R12, UT_5, ht_min, ht_inc, 
 	                               num_heights, iri_options)
#       % get the electron density (Num electrons per m^3)
            elec_dens = iono[0][:]
            elec_dens[elec_dens == -1] = 0

            if doppler_flag:
                elec_dens5 = iono5[0] 
                elec_dens5[elec_dens5 == -1] = 0
            
#       % calculate plasma frequency (MHz) profile and fill the array
            
            iono_pf_subgrid[lon_idx] = np.sqrt(elec_dens * pfsq_conv); 
            if doppler_flag:
                iono_pf_subgrid_5 = np.sqrt(elec_dens5 * pfsq_conv)  
            else:
                iono_pf_subgrid_5 = np.sqrt(elec_dens * pfsq_conv)

#       % electron and ion temperatures
            T_e = iono[3]
            T_e[T_e == -1] = np.nan

            T_ion = iono[2]
            T_ion[T_ion == -1] = np.nan
#       % neutral densities
            if (R12 == -1):
                [neutral_dens, temp] = nrlmsise00(lat_arr, lon_arr, height_arr, UT)
            else:
# 	% calculate f10.7 : see Davies, "Ionospheric Radio", 1990, pp442
                f107 = 63.75 + R12*(0.728 + R12*0.00089)
                [neutral_dens, temp] = \
                nrlmsise00(lat_arr, lon_arr, height_arr, UT, f107, f107, 4)

#       % calculate collision frequency
            collision_freq_subgrid[lon_idx,:] = \
            eff_coll_freq.eff_coll_freq(T_e, T_ion, elec_dens, neutral_dens)
      
#     %%%%%%%%%%%%%%%%%%%
#     % This is IRI2007 %
#     %%%%%%%%%%%%%%%%%%%
        elif profile_type.lower() == 'iri2007':

#       % IRI only returns 100 values for elecron density with height - so
#       % determine the number of  multiple calls required.

            num_heights = round((ht_max - ht_min)/ht_inc) + 1
            max_iri_numhts = 100
            num_iri_calls = np.ceil(num_heights / max_iri_numhts)
            for ii in range(0,num_iri_calls):
    #       % call IRI2007
                height_start = ht_min + (ii-1) * max_iri_numhts * ht_inc

                [iono, iono_extra] = iri2007(lat, lon, R12, UT, ht_min, ht_inc)

                if doppler_flag:
                    [iono5, iono_extra5] = iri2007(lat, lon, R12, UT_5, ht_min, ht_inc)
    #       % get the electron density (Num electrons per m^3)
                remaining_heights = num_heights - (ii - 1)*max_iri_numhts
                idx_end = np.min(remaining_heights, max_iri_numhts)

                elec_dens = iono[0][:,idx_end]
                elec_dens[elec_dens == -1] = 0

                if doppler_flag:
                    elec_dens5 = iono5[0][:,idx_end] 
                    elec_dens5[elec_dens5 == -1] = 0
                
    #       % calculate plasma frequency (MHz) profile and fill the array
                ht_idxa = (ii - 1)*max_iri_numhts + 1
                ht_idxb = ii*max_iri_numhts - (max_iri_numhts - idx_end)
                iono_pf_subgrid[lon_idx][ht_idxa:ht_idxb] = np.sqrt(elec_dens * pfsq_conv); 
                if doppler_flag:
                    iono_pf_subgrid_5[lon_idx][ht_idxa:ht_idxb] = np.sqrt(elec_dens5 * pfsq_conv)  
                else:
                    iono_pf_subgrid_5[lon_idx][ht_idxa:ht_idxb] = np.sqrt(elec_dens * pfsq_conv)

    #       % electron and ion temperatures
                T_e = iono[3]
                T_e[T_e == -1] = np.nan

                T_ion = iono[2]
                T_ion[T_ion == -1] = np.nan
    #       % neutral densities
                if (R12 == -1):
                    [neutral_dens, temp] = nrlmsise00(lat_arr, lon_arr, height_arr, UT)
                else:
    # 	% calculate f10.7 : see Davies, "Ionospheric Radio", 1990, pp442
                    f107 = 63.75 + R12*(0.728 + R12*0.00089)
                    [neutral_dens, temp] = \
                    nrlmsise00(lat_arr, lon_arr, height_arr, UT, f107, f107, 4)

    #       % calculate collision frequency
                collision_freq_subgrid[lon_idx,:] = \
                eff_coll_freq.eff_coll_freq(T_e, T_ion, elec_dens, neutral_dens)

 
    return iono_pf_subgrid, iono_pf_subgrid_5, collision_freq_subgrid
